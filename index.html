<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Doubloon Disaster – Physics Sandbox (Tank Controls + Homing Mines)</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0b1b2b; color:#e9f2ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { display:grid; place-items:center; gap:12px; padding:18px; }
    canvas { background: radial-gradient(1200px 600px at 50% 20%, #0f2e4a, #07131f 70%); border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .hud { display:flex; gap:18px; font-weight:600; align-items:center; flex-wrap:wrap; }
    .btn { cursor:pointer; background:#133455; color:#e9f2ff; border:1px solid #1e4d7a; padding:8px 12px; border-radius:8px; font-weight:700; }
    .btn:active { transform: translateY(1px); }
    .muted { opacity:.85; font-weight:500; }
    a { color:#8bd0ff; }
    .pill { background:#143b60; border:1px solid #215682; padding:2px 8px; border-radius:999px; font-weight:700; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div>Score: <span id="score" class="pill">0</span></div>
      <div>Multiplier: <span id="mult" class="pill">1×</span> <span class="muted" id="chainHint"></span></div>
      <div>Mines: <span id="mineCount" class="pill">0</span></div>
      <div class="muted">Controls: ←/→ rotate, ↑ forward, ↓ reverse, Space restart</div>
      <button id="reset" class="btn" title="Space to quick-restart">Restart ▸</button>
    </div>
    <canvas id="game" width="900" height="600"></canvas>
    <div class="muted">Herd mines together so they collide and explode. Mines wander slowly but will home in when near the boat.</div>
  </div>

  <script>
  // Doubloon Disaster–style sandbox (revised):
  // - Tank/boat controls: left/right rotate; up/down thrust in facing direction
  // - Mines wander slowly; if within aggro radius of the boat they accelerate toward it
  // - Mine–mine collisions cause explosions (remove both), rewarding points and spawning a bonus coin

  const canvas = document.getElementById('game');
  const c = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // --------- Game state ---------
  let boat, mines, coins, explosions, running, score, chainMult, chainTimer, chainWindow, spawnTimers, environmentalEffects;
  let time = 0; // ms

  // Tunables
  const TUNE = {
    // Boat
    boatRadius: 14,
    boatAccel: 0.28,       // thrust per frame (applied to facing)
    boatTurnSpeed: 0.055,  // radians per frame when holding left/right
    boatFriction: 0.985,   // linear velocity damping
    boatMaxSpeed: 5.4,

    // Mines
    mineRadius: 13,
    mineWanderAccel: 0.015,   // random drift accel (slower)
    mineWanderDrag: 0.996,   // keeps them from speeding up from wander
    mineBaseMax: 0.9,
    mineSeekAccel: 0.03,     // gentler accel toward boat when aggroed
    mineSeekMax: 4.8,        // cap speed under seeking (slower than boat)
    mineAggroRadius: 170,    // distance at which mines start homing
    mineStartCount: 2,
    mineMaxCount: 24,
    // mineAddEverySec removed – mines only spawn when you collect a coin

    // Pearls / scoring
    coinRadius: 8,
    coinSpawnEvery: 8000,    // ms - much slower spawn rate
    coinMaxCount: 2,         // maximum pearls at once
    coinSafeRadiusFromBoat: 120,
    chainWindowMs: 2200,
    chainMax: 10,
    coinValue: 1,
    explosionCoinValue: 5,   // bonus when mines collide

    // Environmental effects
    envEffectSpawnEvery: 12000,  // ms between environmental effects
    envEffectDuration: 6000,     // ms how long effects last
    envEffectRadius: 180,        // radius of effect (increased from 120)
    envEffectStrength: 1.5,      // how strong the effect is (increased from 0.8)

    // FX
    explosionLife: 450,      // ms

    // loop
    dt: 1000/60,
  };

  // Input
  const keys = new Set();
  addEventListener('keydown', e => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," ","Space"].includes(e.key)) e.preventDefault();
    if (e.key === ' ') restart();
    keys.add(e.key.toLowerCase());
  });
  addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));
  document.getElementById('reset').onclick = () => restart();

  function rand(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function init(){
    running = true;
    score = 0;
    chainMult = 1;
    chainTimer = 0;
    chainWindow = TUNE.chainWindowMs;

    boat = { x: W*0.5, y: H*0.8, vx:0, vy:0, ang: -Math.PI/2, r:TUNE.boatRadius };

    mines = [];
    for (let i=0;i<TUNE.mineStartCount;i++) mines.push(newMine());

    coins = [];
    explosions = [];
    environmentalEffects = [];
    spawnTimers = { coin: 0, envEffect: 0 };
    time = 0;
  }

  function newMine(){
    // Spawn away from boat
    let x, y; let tries = 0;
    do { x = rand(50, W-50); y = rand(50, H-50); tries++; } while (dist2(x,y,boat.x,boat.y) < 160*160 && tries < 50);
    // Small random initial velocity
    const ang = rand(0, Math.PI*2);
    const spd = rand(0.2, 0.8);
    return { x, y, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, r:TUNE.mineRadius };
  }

  function newCoinAt(x,y){ return { x, y, r: TUNE.coinRadius }; }
  function newCoin(){
    let x, y; let tries = 0;
    do { x = rand(30, W-30); y = rand(30, H-30); tries++; } while (dist2(x,y,boat.x,boat.y) < TUNE.coinSafeRadiusFromBoat**2 && tries < 50);
    return newCoinAt(x,y);
  }

  function dist2(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return dx*dx+dy*dy; }
  function circleHit(a,b){ const r = a.r + b.r; return dist2(a.x,a.y,b.x,b.y) <= r*r; }

  function addExplosion(x,y){
    explosions.push({ x,y, t:TUNE.explosionLife });
  }

  function newEnvironmentalEffect(){
    const types = ['maelstrom', 'whirlpool', 'wind', 'wave'];
    const type = types[Math.floor(Math.random() * types.length)];
    let x, y; let tries = 0;
    do { x = rand(100, W-100); y = rand(100, H-100); tries++; } while (dist2(x,y,boat.x,boat.y) < 200*200 && tries < 50);
    return { 
      x, y, 
      type, 
      t: TUNE.envEffectDuration,
      r: TUNE.envEffectRadius,
      strength: TUNE.envEffectStrength,
      angle: rand(0, Math.PI*2) // for directional effects like wind
    };
  }

  function physicsStep(dt){
    if (!running) return;

    // --- Input → rotation + thrust (tank controls)
    const up = keys.has('arrowup') || keys.has('w');
    const dn = keys.has('arrowdown') || keys.has('s');
    const lf = keys.has('arrowleft') || keys.has('a');
    const rt = keys.has('arrowright') || keys.has('d');

    if (lf) boat.ang -= TUNE.boatTurnSpeed;
    if (rt) boat.ang += TUNE.boatTurnSpeed;

    const fx = Math.cos(boat.ang);
    const fy = Math.sin(boat.ang);
    if (up) { boat.vx += fx * TUNE.boatAccel; boat.vy += fy * TUNE.boatAccel; }
    if (dn) { boat.vx -= fx * (TUNE.boatAccel*0.7); boat.vy -= fy * (TUNE.boatAccel*0.7); }

    // Friction + clamp speed
    boat.vx *= TUNE.boatFriction;
    boat.vy *= TUNE.boatFriction;
    const spd = Math.hypot(boat.vx, boat.vy);
    if (spd > TUNE.boatMaxSpeed){ const k=TUNE.boatMaxSpeed/spd; boat.vx*=k; boat.vy*=k; }

    // Integrate position and clamp
    boat.x = clamp(boat.x + boat.vx, boat.r, W-boat.r);
    boat.y = clamp(boat.y + boat.vy, boat.r, H-boat.r);

    // --- Mines: wander + conditional homing, wall bounce, collisions
    for (const m of mines){
      // Wander: small random acceleration
      m.vx += rand(-TUNE.mineWanderAccel, TUNE.mineWanderAccel);
      m.vy += rand(-TUNE.mineWanderAccel, TUNE.mineWanderAccel);

      // If within aggro radius, accelerate toward boat
      const d2 = dist2(m.x,m.y,boat.x,boat.y);
      if (d2 < TUNE.mineAggroRadius*TUNE.mineAggroRadius){
        const d = Math.sqrt(d2) || 1;
        const ax = (boat.x - m.x)/d * TUNE.mineSeekAccel;
        const ay = (boat.y - m.y)/d * TUNE.mineSeekAccel;
        m.vx += ax; m.vy += ay;
        // Cap speed while seeking
        const ms = Math.hypot(m.vx, m.vy);
        if (ms > TUNE.mineSeekMax){ const k=TUNE.mineSeekMax/ms; m.vx*=k; m.vy*=k; }
      } else {
        // Damp so wandering stays slow
        m.vx *= TUNE.mineWanderDrag; m.vy *= TUNE.mineWanderDrag;
        const ms = Math.hypot(m.vx, m.vy);
        if (ms > TUNE.mineBaseMax){ const k=TUNE.mineBaseMax/ms; m.vx*=k; m.vy*=k; }
      }

      // Integrate + wall bounce
      m.x += m.vx; m.y += m.vy;
      if (m.x < m.r){ m.x = m.r; m.vx *= -1; }
      if (m.x > W-m.r){ m.x = W-m.r; m.vx *= -1; }
      if (m.y < m.r){ m.y = m.r; m.vy *= -1; }
      if (m.y > H-m.r){ m.y = H-m.r; m.vy *= -1; }

      // Boat collision → game over
      if (circleHit(boat, m)) running = false;
    }

    // Mine–mine collisions → explode (remove both), spawn coin, score bonus
    for (let i=0;i<mines.length;i++){
      for (let j=i+1;j<mines.length;j++){
        const a=mines[i], b=mines[j];
        if (!a || !b) continue;
        const rr = (a.r + b.r);
        if (dist2(a.x,a.y,b.x,b.y) <= rr*rr){
          // Explosion at midpoint
          const ex = (a.x + b.x)/2, ey = (a.y + b.y)/2;
          addExplosion(ex,ey);
          // Remove b then a (higher index first)
          mines.splice(j,1); mines.splice(i,1);
          // Score + bonus coin spawn
          score += TUNE.explosionCoinValue * chainMult;
          coins.push(newCoinAt(ex + rand(-10,10), ey + rand(-10,10)));
          // Adjust indices
          i--; break;
        }
      }
    }

    // Coin collection + chain
    for (let i = coins.length-1; i >= 0; i--){
      if (circleHit(boat, coins[i])){
        coins.splice(i,1);
        chainMult = Math.min(TUNE.chainMax, chainMult + 1);
        chainTimer = chainWindow;
        score += TUNE.coinValue * chainMult;
        // Spawn a new mine only when a coin is collected
        if (mines.length < TUNE.mineMaxCount) mines.push(newMine());
      }
    }

    // Chain timer decay
    if (chainTimer > 0){
      chainTimer -= dt; if (chainTimer <= 0){ chainTimer = 0; chainMult = 1; }
    }

    // Spawning cadence
    spawnTimers.coin += dt;
    if (spawnTimers.coin >= TUNE.coinSpawnEvery && coins.length < TUNE.coinMaxCount){ 
      spawnTimers.coin = 0; 
      coins.push(newCoin()); 
    }

    // Environmental effects spawning
    spawnTimers.envEffect += dt;
    if (spawnTimers.envEffect >= TUNE.envEffectSpawnEvery){ 
      spawnTimers.envEffect = 0; 
      environmentalEffects.push(newEnvironmentalEffect()); 
    }
    

    // Environmental effects decay and physics
    for (let i=environmentalEffects.length-1;i>=0;i--){
      const effect = environmentalEffects[i];
      effect.t -= dt; 
      if (effect.t <= 0) {
        environmentalEffects.splice(i,1);
        continue;
      }

      // Apply environmental effects to boat and mines
      const effectProgress = 1 - (effect.t / TUNE.envEffectDuration);
      const currentStrength = effect.strength * (0.5 + 0.5 * Math.sin(effectProgress * Math.PI)); // fade in/out

      // Boat effects
      const boatDist = Math.sqrt(dist2(boat.x, boat.y, effect.x, effect.y));
      if (boatDist < effect.r) {
        const influence = (effect.r - boatDist) / effect.r;
        const force = currentStrength * influence * 0.02;

        if (effect.type === 'maelstrom') {
          // Pull toward center
          const dx = (effect.x - boat.x) / boatDist;
          const dy = (effect.y - boat.y) / boatDist;
          boat.vx += dx * force;
          boat.vy += dy * force;
        } else if (effect.type === 'whirlpool') {
          // Circular motion
          const perpX = -(boat.y - effect.y) / boatDist;
          const perpY = (boat.x - effect.x) / boatDist;
          boat.vx += perpX * force;
          boat.vy += perpY * force;
        } else if (effect.type === 'wind') {
          // Push in wind direction
          boat.vx += Math.cos(effect.angle) * force;
          boat.vy += Math.sin(effect.angle) * force;
        } else if (effect.type === 'wave') {
          // Push away from center
          const dx = (boat.x - effect.x) / boatDist;
          const dy = (boat.y - effect.y) / boatDist;
          boat.vx += dx * force;
          boat.vy += dy * force;
        }
      }

      // Mine effects (same logic but weaker)
      for (const m of mines) {
        const mineDist = Math.sqrt(dist2(m.x, m.y, effect.x, effect.y));
        if (mineDist < effect.r) {
          const influence = (effect.r - mineDist) / effect.r;
          const force = currentStrength * influence * 0.01; // weaker for mines

          if (effect.type === 'maelstrom') {
            const dx = (effect.x - m.x) / mineDist;
            const dy = (effect.y - m.y) / mineDist;
            m.vx += dx * force;
            m.vy += dy * force;
          } else if (effect.type === 'whirlpool') {
            const perpX = -(m.y - effect.y) / mineDist;
            const perpY = (m.x - effect.x) / mineDist;
            m.vx += perpX * force;
            m.vy += perpY * force;
          } else if (effect.type === 'wind') {
            m.vx += Math.cos(effect.angle) * force;
            m.vy += Math.sin(effect.angle) * force;
          } else if (effect.type === 'wave') {
            const dx = (m.x - effect.x) / mineDist;
            const dy = (m.y - effect.y) / mineDist;
            m.vx += dx * force;
            m.vy += dy * force;
          }
        }
      }
    }

    // Explosions decay
    for (let i=explosions.length-1;i>=0;i--){
      explosions[i].t -= dt; if (explosions[i].t <= 0) explosions.splice(i,1);
    }

    // HUD
    document.getElementById('score').textContent = score;
    document.getElementById('mult').textContent = chainMult + '×';
    const hint = document.getElementById('chainHint');
    hint.textContent = chainMult>1 ? ` (chain ${Math.ceil(chainTimer/1000)}s)` : '';
    document.getElementById('mineCount').textContent = mines.length;
  }

  function draw(){
    c.clearRect(0,0,W,H);

    // ─────────────────────────────────────────────────────────────────────────────
    // PEARLS (replaces your // Coins loop)
    // ─────────────────────────────────────────────────────────────────────────────
    for (const coin of coins) {
      c.save();

      // deterministic "random" from position for consistent variety
      const fract = v => v - Math.floor(v);
      const seed = fract(Math.sin(coin.x * 12.9898 + coin.y * 78.233) * 43758.5453);

      // 12% chance: rare colored pearls
      const rare = seed < 0.12;
      // pick a rare tint bucket
      let tint; // {h,s,l} for hsl
      if (rare) {
        if (seed < 0.03)      tint = { h: 205, s: 35, l: 28, kind: 'black'   }; // black/peacock-dark
        else if (seed < 0.06) tint = { h: 335, s: 45, l: 72, kind: 'rose'    }; // rose
        else if (seed < 0.09) tint = { h: 260, s: 35, l: 78, kind: 'lavender'}; // lavender
        else                  tint = { h: 45,  s: 65, l: 70, kind: 'golden'  }; // golden
      } else {
        tint = { h: 30, s: 18, l: 92, kind: 'classic' }; // warm ivory
      }

      // pearl body with iridescent radial gradient
      const r = coin.r;
      const gx = coin.x - r * 0.35, gy = coin.y - r * 0.35;
      const body = c.createRadialGradient(gx, gy, r * 0.15, coin.x, coin.y, r);
      if (tint.kind === 'black') {
        body.addColorStop(0.00, 'rgba(255,255,255,0.85)');
        body.addColorStop(0.35, `hsl(${tint.h} ${tint.s}% ${Math.max(20, tint.l - 8)}%)`);
        body.addColorStop(0.70, `hsl(${(tint.h+30)%360} ${Math.max(20, tint.s-10)}% ${Math.max(12, tint.l-18)}%)`);
        body.addColorStop(1.00, 'rgba(0,0,0,0.55)');
      } else {
        body.addColorStop(0.00, 'rgba(255,255,255,0.95)');
        body.addColorStop(0.35, `hsl(${tint.h} ${tint.s}% ${tint.l}%)`);
        body.addColorStop(0.70, `hsl(${(tint.h+40)%360} ${Math.max(10, tint.s-12)}% ${Math.max(70, tint.l-8)}%)`);
        body.addColorStop(1.00, 'rgba(60,60,60,0.15)');
      }

      // base sphere
      c.beginPath();
      c.arc(coin.x, coin.y, r, 0, Math.PI * 2);
      c.fillStyle = body;
      c.fill();

      // thin rim sheen
      c.lineWidth = 1;
      c.strokeStyle = 'rgba(255,255,255,0.35)';
      c.stroke();

      // specular highlight
      c.beginPath();
      c.ellipse(coin.x - r * 0.38, coin.y - r * 0.38, r * 0.35, r * 0.22, Math.PI / 6, 0, Math.PI * 2);
      c.fillStyle = 'rgba(255,255,255,0.55)';
      c.fill();

      // faint interference band for iridescence
      c.beginPath();
      c.ellipse(coin.x + r * 0.10, coin.y + r * 0.05, r * 0.85, r * 0.55, -Math.PI / 8, 0, Math.PI * 2);
      c.strokeStyle = rare ? 'rgba(255,255,255,0.10)' : 'rgba(255,255,255,0.06)';
      c.lineWidth = 1;
      c.stroke();

      c.restore();
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // FANCY MINES with pulsing red beacon (replaces your // Mines loop)
    // ─────────────────────────────────────────────────────────────────────────────
    const nowSec = ((typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now()) * 0.001;

    for (const m of mines) {
      c.save();

      // sphere shading
      const rg = c.createRadialGradient(m.x - m.r * 0.4, m.y - m.r * 0.4, m.r * 0.2, m.x, m.y, m.r * 1.1);
      rg.addColorStop(0.00, '#596579');  // highlight
      rg.addColorStop(0.55, '#2a3747');  // mid
      rg.addColorStop(1.00, '#151c24');  // shadow

      c.beginPath();
      c.arc(m.x, m.y, m.r, 0, Math.PI * 2);
      c.fillStyle = rg;
      c.fill();

      // rim highlight
      c.lineWidth = 2;
      c.strokeStyle = 'rgba(220,235,255,0.25)';
      c.stroke();

      // panel seam (equator)
      c.beginPath();
      c.arc(m.x, m.y, m.r * 0.78, 0, Math.PI * 2);
      c.strokeStyle = 'rgba(180,200,220,0.25)';
      c.lineWidth = 1.5;
      c.stroke();

      // rivets around seam
      const rivets = 14;
      for (let i = 0; i < rivets; i++) {
        const ang = (i / rivets) * Math.PI * 2;
        const rx = m.x + Math.cos(ang) * m.r * 0.78;
        const ry = m.y + Math.sin(ang) * m.r * 0.78;
        c.beginPath();
        c.arc(rx, ry, Math.max(1.5, m.r * 0.06), 0, Math.PI * 2);
        c.fillStyle = '#a9bfd6';
        c.fill();
        c.lineWidth = 1;
        c.strokeStyle = '#5c6d80';
        c.stroke();
      }

      // spikes with caps
      const spikes = 10;
      for (let i = 0; i < spikes; i++) {
        const ang = (i / spikes) * Math.PI * 2;
        const baseR = m.r * 0.65;
        const tipR  = m.r * 1.18;
        const bx = m.x + Math.cos(ang) * baseR;
        const by = m.y + Math.sin(ang) * baseR;
        const tx = m.x + Math.cos(ang) * tipR;
        const ty = m.y + Math.sin(ang) * tipR;

        // spike shaft
        c.beginPath();
        c.moveTo(bx, by);
        c.lineTo(tx, ty);
        c.lineWidth = Math.max(2, m.r * 0.10);
        c.strokeStyle = '#7f93a8';
        c.stroke();

        // cap
        c.beginPath();
        c.arc(tx, ty, Math.max(2, m.r * 0.12), 0, Math.PI * 2);
        c.fillStyle = '#c8d6e6';
        c.fill();
        c.lineWidth = 1.5;
        c.strokeStyle = '#6e8298';
        c.stroke();
      }

      // pulsing red beacon in center
      const phase = nowSec * 6 + (m.x + m.y) * 0.03; // slight desync per mine
      const pulse = 0.5 + 0.5 * Math.sin(phase);     // 0..1
      const coreR = Math.max(2, m.r * 0.12);
      const glowR = coreR + m.r * (0.18 + 0.18 * pulse);
      const cx = m.x, cy = m.y;

      // glow
      c.save();
      c.globalCompositeOperation = 'lighter';
      c.beginPath();
      c.arc(cx, cy, glowR, 0, Math.PI * 2);
      c.fillStyle = `rgba(255,0,0,${0.18 + 0.35 * pulse})`;
      c.shadowColor = 'rgba(255,0,0,1)';
      c.shadowBlur = 8 + 16 * pulse;
      c.fill();

      // bright core
      c.beginPath();
      c.arc(cx, cy, coreR, 0, Math.PI * 2);
      c.fillStyle = '#ff2b2b';
      c.shadowBlur = 0;
      c.fill();

      // glossy highlight on core
      c.beginPath();
      c.ellipse(cx - coreR * 0.25, cy - coreR * 0.25, coreR * 0.55, coreR * 0.35, Math.PI / 8, 0, Math.PI * 2);
      c.fillStyle = 'rgba(255,255,255,0.6)';
      c.fill();
      c.restore();

      c.restore();
    }

    // Environmental effects
    for (const effect of environmentalEffects) {
      const progress = 1 - (effect.t / TUNE.envEffectDuration);
      const alpha = 0.3 + 0.4 * Math.sin(progress * Math.PI); // fade in/out
      const pulse = 0.8 + 0.2 * Math.sin(time * 0.003 + effect.x * 0.01);

      c.save();
      c.globalAlpha = alpha;

      if (effect.type === 'maelstrom') {
        // Dark swirling vortex
        c.beginPath();
        c.arc(effect.x, effect.y, effect.r * pulse, 0, Math.PI * 2);
        c.strokeStyle = `rgba(100,50,150,${alpha})`;
        c.lineWidth = 4;
        c.stroke();
        
        // Inner spiral
        for (let i = 0; i < 3; i++) {
          c.beginPath();
          const spiralR = effect.r * (0.3 + 0.4 * i / 3) * pulse;
          const spiralAngle = time * 0.002 + i * Math.PI * 2 / 3;
          c.arc(effect.x, effect.y, spiralR, spiralAngle, spiralAngle + Math.PI * 1.5);
          c.strokeStyle = `rgba(150,100,200,${alpha * 0.6})`;
          c.lineWidth = 2;
          c.stroke();
        }
      } else if (effect.type === 'whirlpool') {
        // Blue swirling water
        c.beginPath();
        c.arc(effect.x, effect.y, effect.r * pulse, 0, Math.PI * 2);
        c.strokeStyle = `rgba(50,100,200,${alpha})`;
        c.lineWidth = 3;
        c.stroke();
        
        // Concentric circles
        for (let i = 1; i <= 3; i++) {
          c.beginPath();
          c.arc(effect.x, effect.y, effect.r * (i / 4) * pulse, 0, Math.PI * 2);
          c.strokeStyle = `rgba(80,150,255,${alpha * 0.4})`;
          c.lineWidth = 1.5;
          c.stroke();
        }
      } else if (effect.type === 'wind') {
        // Invisible but show direction with arrows
        const arrowCount = 8;
        for (let i = 0; i < arrowCount; i++) {
          const angle = (i / arrowCount) * Math.PI * 2;
          const dist = effect.r * (0.3 + 0.4 * Math.random()) * pulse;
          const ax = effect.x + Math.cos(angle) * dist;
          const ay = effect.y + Math.sin(angle) * dist;
          
          c.beginPath();
          c.moveTo(ax, ay);
          c.lineTo(ax + Math.cos(effect.angle) * 15, ay + Math.sin(effect.angle) * 15);
          c.strokeStyle = `rgba(200,200,255,${alpha * 0.6})`;
          c.lineWidth = 2;
          c.stroke();
        }
      } else if (effect.type === 'wave') {
        // Expanding wave rings
        const ringCount = 3;
        for (let i = 0; i < ringCount; i++) {
          const ringProgress = (progress + i * 0.3) % 1;
          const ringR = effect.r * ringProgress * pulse;
          c.beginPath();
          c.arc(effect.x, effect.y, ringR, 0, Math.PI * 2);
          c.strokeStyle = `rgba(100,150,255,${alpha * (1 - ringProgress)})`;
          c.lineWidth = 3 - ringProgress * 2;
          c.stroke();
        }
      }

      c.restore();
    }

    // Explosions (simple expanding rings)
    for (const e of explosions){
      const p = 1 - (e.t / TUNE.explosionLife);
      const R = 12 + p*26;
      c.beginPath(); c.arc(e.x, e.y, R, 0, Math.PI*2);
      c.strokeStyle = `rgba(255,230,160,${1-p})`; c.lineWidth = 3; c.stroke();
      c.beginPath(); c.arc(e.x, e.y, R*0.6, 0, Math.PI*2);
      c.strokeStyle = `rgba(255,180,80,${0.8*(1-p)})`; c.lineWidth = 2; c.stroke();
    }

    // Boat (Qatari-style dhow, top-down)
    c.save();
    c.translate(boat.x, boat.y);
    c.rotate(boat.ang);

    // proportions (tweak to taste)
    const L = boat.r * 2.6;   // half-length
    const B = boat.r * 0.9;   // half-beam

    // soft shadow for depth
    c.shadowColor = 'rgba(0,0,0,0.25)';
    c.shadowBlur = 12;
    c.shadowOffsetY = 2;

    // wood gradient
    const wood = c.createLinearGradient(-L, 0, L, 0);
    wood.addColorStop(0.00, '#8a5a3b');
    wood.addColorStop(0.45, '#a06b47');
    wood.addColorStop(0.55, '#b77b4f');
    wood.addColorStop(1.00, '#8a5a3b');

    // hull outline (teardrop w/ flatter stern)
    c.beginPath();
    c.moveTo(-L * 0.85, -B * 0.60);                        // stern, port
    c.quadraticCurveTo(-L * 0.20, -B * 1.10,  L * 0.92, 0); // sheer to bow point
    c.quadraticCurveTo(-L * 0.20,  B * 1.10, -L * 0.85,  B * 0.60); // back along starboard
    c.quadraticCurveTo(-L * 0.97,  0,        -L * 0.85, -B * 0.60); // roundish stern
    c.closePath();
    c.fillStyle = wood;
    c.fill();

    c.lineWidth = 2;
    c.strokeStyle = '#3a2418';
    c.stroke();

    // thin gunwale highlight
    c.lineWidth = 1;
    c.strokeStyle = 'rgba(255,255,255,0.25)';
    c.stroke();

    // dark prow cap (distinctive dhow bow)
    c.beginPath();
    c.moveTo( L * 0.92, 0);
    c.lineTo( L * 0.68, -B * 0.34);
    c.lineTo( L * 0.68,  B * 0.34);
    c.closePath();
    c.fillStyle = '#6d4630';
    c.fill();

    // deck planking (subtle arcs)
    c.lineWidth = 1;
    for (let t = -B * 0.75; t <= B * 0.75; t += B / 6) {
      c.beginPath();
      c.moveTo(-L * 0.72, t);
      c.quadraticCurveTo(0, t * 1.25, L * 0.72, t);
      c.strokeStyle = 'rgba(255,255,255,0.06)';
      c.stroke();
    }

    // centerline
    c.beginPath();
    c.moveTo(-L * 0.70, 0);
    c.quadraticCurveTo(0, 0, L * 0.70, 0);
    c.strokeStyle = 'rgba(0,0,0,0.12)';
    c.stroke();

    // mast (forward of center) + lateen spar hint
    const mastX = L * 0.25;
    c.fillStyle = '#5a3b29';
    c.beginPath(); c.arc(mastX, 0, Math.max(2, boat.r * 0.12), 0, Math.PI * 2); c.fill();
    c.lineWidth = 2;
    c.strokeStyle = 'rgba(0,0,0,0.25)';
    c.beginPath();
    c.moveTo(mastX, 0);
    c.lineTo(-L * 0.30, -B * 0.35); // angled spar/boom hint
    c.stroke();

    // small deckhouse aft
    c.fillStyle = '#6f4a32';
    const dhx = -L * 0.45, dhw = L * 0.28, dhh = B * 0.36;
    c.fillRect(dhx - dhw/2, -dhh/2, dhw, dhh);

    // light rim on deckhouse
    c.strokeStyle = 'rgba(255,255,255,0.12)';
    c.lineWidth = 1;
    c.strokeRect(dhx - dhw/2, -dhh/2, dhw, dhh);

    c.restore();

    if (!running){
      c.fillStyle = 'rgba(0,0,0,0.55)'; c.fillRect(0,0,W,H);
      c.fillStyle = '#e9f2ff'; c.font = '700 36px system-ui, sans-serif'; c.textAlign = 'center';
      c.fillText('Game Over', W/2, H/2 - 14);
      c.font = '500 18px system-ui, sans-serif'; c.fillText('Press Space to Restart', W/2, H/2 + 18);
    }
  }

  function loop(ts){
    if (!loop.last) loop.last = ts; let dt = ts - loop.last; loop.last = ts; time += dt;
    loop.acc = (loop.acc || 0) + dt;
    while (loop.acc >= TUNE.dt){ physicsStep(TUNE.dt); loop.acc -= TUNE.dt; }
    draw();
    requestAnimationFrame(loop);
  }

  function restart(){ init(); }

  // Boot
  init();
  requestAnimationFrame(loop);
  </script>
</body>
</html>
